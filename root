{"version":1,"ops":[{"type":1,"author":{"id":"67fe295bcc0467c8a82b681f26fdec03562acd8d"},"timestamp":1598934982,"metadata":{"github-id":"MDU6SXNzdWU2ODk4MDEyNjQ=","github-url":"https://github.com/rurban/Net-Ping/issues/21","origin":"github"},"title":"Patch to fix icmpv6 ping","message":"The problem is seen in Net::Ping in the Perl core, version \nperl-5.30.1-4.2.x86_64 from OpenSuSE Tumbleweed.  \nPackage $VERSION = 2.71\n\nI ran the following tester (comments and debug stuff omitted):\n    use Net::Ping;\n    my $holly4 = \"192.9.200.199\";\n    my $holly6 = \"[2600:3c01:e000:306::c7]\";\n    my @proto; @proto[qw(4 6)] = qw(icmp icmpv6);\n    foreach my $ip (($holly4, $holly6)) {\n        my $AF = (index($ip, ':') \u003e= 0) ? 6 : 4;\n        my $p = Net::Ping-\u003enew($proto[$AF], 1); \n        my $hrc = $p-\u003eping($ip);\n        print \"rc = $hrc  AF = $AF  $ip\\n\";\n    }\n\nIt returns $hrc = 1 (success) when pinging the IPv4 address, but failure\nfor IPv6, plus several complaints about substring outside of string, and\nresulting undefined arguments to functions.  The problem is seen in\nmultiple apps whenever ping() gets hold of an IPv6 address, either from\ngetaddrinfo or as a literal address.\n\nIt turns out that ICMP returns the IP header (20 octets) plus the \npayload (8 octets), while ICMPv6 returns only the payload.  I've \nincluded a patch to adjust the payload location per address family,\nwhich enables it to ping both families reliably.  I also added an item\nto the POD illustrating that the literal IPv6 address has to be in \n[brackets] and that icmpv6 has to be used.  \n\nI didn't test other ping protocols; they might have related issues with\nIPv6 and I wouldn't know.  \n\nI wonder if the icmp and icmpv6 protocol keywords could be interchanged\ndynamically according to the address family inferred from the IP, which\ncould be either when an alphabetic hostname is resolved.  But I didn't\ntry implementing this.  \n\nPatch: \n--- Ping.pm.orig        2020-07-22 02:30:10.000000000 -0700\n+++ Ping.pm     2020-08-31 17:35:22.676506494 -0700\n@@ -770,7 +770,12 @@\n       $from_seq = -1;\n       $from_saddr = recv($self-\u003e{fh}, $recv_msg, 1500, ICMP_FLAGS);\n       ($from_port, $from_ip) = _unpack_sockaddr_in($from_saddr, $ip-\u003e{family});\n-      ($from_type, $from_subcode) = unpack(\"C2\", substr($recv_msg, 20, 2));\n+               # Looks like ICMP echo includes the header and ICMPv6 doesn't.\n+               # IPv4 length($recv_msg) is 28 (20 header + 8 payload) while \n+               # IPv6 length is only 8.  $pyld = where the payload really \n+               # starts. \n+      my $pyld = ($ip-\u003e{family} == AF_INET) ? 20 : 0;\n+      ($from_type, $from_subcode) = unpack(\"C2\", substr($recv_msg, $pyld, 2));\n       if ($from_type == ICMP_TIMESTAMP_REPLY) {\n         ($from_pid, $from_seq) = unpack(\"n3\", substr($recv_msg, 24, 4))\n           if length $recv_msg \u003e= 28;\n@@ -2012,6 +2017,10 @@\n     }\n     $p-\u003eclose();\n \n+    $p = Net::Ping-\u003enew(\"icmpv6\");\n+    $ip = \"[fd00:dead:beef::4e]\";\n+    print \"$ip is alive.\\n\" if $p-\u003eping($ip);\n+\n     $p = Net::Ping-\u003enew(\"tcp\", 2);\n     # Try connecting to the www port instead of the echo port\n     $p-\u003eport_number(scalar(getservbyname(\"http\", \"tcp\")));","files":null}]}